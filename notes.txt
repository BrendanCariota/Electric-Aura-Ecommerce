---------------------------------
CREATING A FULL STACK APPLICATION
---------------------------------

FOLDER SETUP
We will have TWO folder in our project folder [frontend, backend]
- FRONTEND - this is created with (npx create-react-app frontend) and is where we will install all of our frontend/react dependencies
- BACKEND - this is created manually and will hold our server.js file as to run our backend as well as our env files and routes

GIT
We will use (git init) in our main project root folder to initialze a git repository at the root encompassing both the frontend and backend folders

FRONTEND
The frontend is setup like a traditional react application installing all of the dependencies need in the frontend section
We can use npm start to run this as it's own seperate thing in the being to get basic functionalty and styling

BACKEND
After we create the backend folder we will create our server.js file to start our server

SETTING UP THE BACKEND
We must install a few useful packages (express, dotenv) 
Express lets us interact easily with our database and dotenv lets us setup an (.env) file to house import information like our PORT and MONGO_URI
We will use the newer es7 module syntax to import what we need vs the older require syntax
To utilze this feature we need to add ("type": "module",) to our global package.json file
- 1. We can now import express to connect to our server (import express from 'express') notice this syntax is the same as react to make things easier
- 2. We can import dotenv and setup an (.env) file to house our basic information as the start
- (.env) we will put our PORT=5000 and our MONGO_URI in this file for now
- 3. Run express (const app = express())
We can now start setting up some basic routes
We will set up (app.get("/), (req, res) => { res.send("The is the home page") }) just to make sure we can hit our routes
Finally we will setup our listen so we can actually tell the server where to run on our local machine
- const PORT = process.env.PORT - this will set our PORT from our .env file to this variable for use in our application 
- (app.listen(PORT, console.log(Server started on port ${PORT})))
- to send static data from it we can just use res.json(data) to pass the json data when we hit the link we are looking for
- We can now run our server

SETTING UP NODEMON AND CONCURRENTLY
We will set these two things up real quick to make development much easier
- 1. Install nodemon and concurrently in the root folder
- 2. We will then go to the root package.json and add the following
-   "start": "node backend/server",
    "server": "nodemon backend/server",
    "client": "npm start --prefix frontend",
    "dev": "concurrently \"npm run server\" \"npm run client\""
This will allow us to run both the react frontend and the backend with nodemon by utilzing the (npm run dev) command

SETTING UP AND CONNECTING MONGODB
We will set up a MongoDB cluster and database like normal
- Make sure to add yourself as a user and add your ip address so we can connect
We will now install MONGOOSE to manipulate our database
- npm install mongoose in our root folder
We will now create a Database connection file
- 1. Create a new folder called configs in our backend folder
- 2. create a file (db.js) -> This will be where we connect to our database
- 3. import mongoose and setup our async function to connect to the database
- 4. Import our function for connecting into our (server.js) file
- 5. Call that function and we should be good to connect

MODELING OUR DATA
Create a models folder in our backend and setup the models we need
In this case its Users, Products, and Orders
Create and export the schemas

PREPARING TEMPORARY DATA TO BUILD THE APPLICATION
- Install (bcryptjs) in root folder so we can hash our passwords (encrypt)
- Create a products.js and users.js file following our schema so we have some information to work with
- Hash the user passwords with bcryptjs
- CREATE A SEEDER SCRIPT (Temporary) to seed our Mongo Database with the products and users we created
- seeder script at (seeder.js)

FETCHING PRODUCTS FROM THE Database
We will create a routes folder in our backend to help maintain structure
- 1. Start with creating the proudctRoutes file (productRoutes.js)
- - We will import express and utilze router
- - Create the routes
- 2. Connect them to (server.js) by importing the (productRoutes.js) file
- - Next we will app.use(/api/products) because all of our productRoutes will start with that
- 3. Install express-async-handler which is a middleware that handles our try catches so we dont have to
- - Add middleware to routes
- 4. Setup POSTMAN
- MIDDLEWARE is a function that has access to the (req, res) life cycle
- - We will create a middleware folder in our backend and the create or errorMiddleware file
- - create the two pieces of middleware
- - Import them into our (server.js) and call them at the bottom with (app.use())

REDUX
- 1. Install redux, react-redux redux-thunk(make async req in action creators) redux-devtools-extension
- 2. Create (store.js) file in src folder in frontend
- 3. To implement our store we need to use a proivder (react-redux) in our (index.js) file

REDUCERS
- 1. Setup a reducers folder in our src
- 2. We will start setting up the productReducer
- 3. To use the reducers we must add it to (store.js)

ACTIONS
- 1. Create an actions folder in our source
- 2. We will start by creating our productActions

BRINGING REDUX STATE TO OUR HOME SCREEN
- - We no longer need to keep our state in our HomeScreen component or use our useEffect to fetch the products from the backend
- 1. Import useDispatch and useSelector from 'react-redux' in our Home Screen
- - useSelector is used to grab pieces of state from redux

CREATING NEW FUNCTIONALITY
- 1. [Constants] Add new constants to use in your reducers (constants) folder
- 2. [Reducer] Create a new reducer for the functionality
- 3. [Store] When a new reducer is created we need to add it to our store
- 4. [Action] Create a new action
- 5. [Component] Go to the component and useDispatch and useSelector to incorporate the state into your component and bring in action

CONTROLLERS
- 1. In backend create a folder for our controllers
- - We just want our routes pointing at routes so we will put the logic into the controllers
- 2. Import our models and asyncHandler into this file that way our routes file can just point to it

USER AUTHENTICATION ENDPOINT
- 1. Create a userRoute and userController
- 2. Add this app.use(express.json()) to our (server.js) so we can parse JSON data
- 3. Add the route to (server.js)
- 4. Add bcrypt to our USER model to handle the encrypted passwords
- 5. Implement the bcrypt function in the (userController) to check if the passwords match if not throw an errorMiddleware

JWT (JSON WEB TOKENS)
- - AUTHENTICATION - Authenticate (Create) a user in the database or see if they are already in there
- - AUTHENTICATION - Give that authenticated user access to part of the webpage they are allowed
- 1. Install jsonwebtoken
- 2. Create a (generateToken.js) file to put your function
- 3. Add the JWT_SECRET in our (.evn) file
- 4. Add the functionality to our (userController.js)

CUSTOM AUTHENTICATION MIDDLEWARE
- 1. Add a new function getUserProfile to our (userController.js)
- 2. Add that route to our (userRoutes.js) file so we can hit it
- 3. In our middleware folder create a new file (authMiddleware.js)
- 4. Create the middleware besure to call (next()) because were are working with middleware
- 5. Import the middleware into our (userRoutes.js) and pass it as the first argument to use it
- 6. We can now add protect wherever we want to protect a route

SAVE THE TOKEN IN POSTMAN
- 1. Get rid of current header if there is one
- 2. Add a test on our /login route -- pm.environment.set("TOKEN", pm.response.json().token)
- 3. Go to authorization on a protect route in our case /profile
- 4. Choose 'Bearer Token' and make sure the variable is passed in

USER REGISTRATION AND PASSWORD ENCRYPTION
- 1. Setup Postman route
- 2. Create function in (userController.js)
- 3. Import that function in (userRoutes.js)
- 4. ENCRYPT THE PASSWORD
- - 1. To do this we will go to our (userModel.js) and create a piece of middleware that will let us do something on saves, finds, or other actions
- - 2. Before we save will add middleware to encrypt password using bcrypt
- - 3. we will call the method but add .pre because we want this to happen before the save

USER LOGIN REDUCER AND ACTION
- 1. Create the constant
- 2. Create our (userReducers.js)
- 3. Bring it in to our (store.js)
- 5. Create our (userActions.js)
- 6. We need to go to our (store.js) and load our initial userInfo for localStorage like we did with our cart items

USER LOGIN SCREEN AND FUNCTIONALITY
- 1. Create new screen (LoginScreen.js)
- 2. We will also create a new component (FormContainer.js) because we will reuse this for our other forms in our application
- 3. Create a route for the (LoginScreen.js) so we can see it by going to (App.js)

SHOW USER IN NAVBAR AND LOGOUT
- 1. Go to (Header.js) we will add functionality to change 'Sign In' to the users name once they are signed in
- - 1. Import useDispatch, useSelector so we can get our state as well as call our logout action
- - 2. Use parenthesis to create a condition to display based on if (userInfo) exists
- - 3. Go to our (userActions.js) and create our logout userActions
- - - 1. our logout action consisists of removing 'userInfo' from localStorage and dispatching USER_LOGOUT
- - 4. We then dispatch this action in our (Header.js) file to log our user out

USER REGISTER REDUCER, ACTION, SCREEN
- 1. Create new user contants in (userConstants.js) for registering
- 2. Create a userRegisterReducer in (userReducer.js)
- 3. Bring in the reducer to (store.js)
- 4. Create a register action in (userActions.js)
- 5. Create the screen for registering (RegisterScreen.js)
- 6. Add the Screen in (App.js)

CREATING OUR UPDATE PROFILE ENDPOINT (BACKEND)
- 1. Add an updateUserProfile Controller which is a PUT request to our (userController.js) in the backend
- 2. Bring it in to our (userRoutes.js)

PROFILE SCREEN AND GET USER DETAILS
- 1. Create constants for USER_DETAILS
- 2. Create a new reducer
- 3. Import reducer to (store.js)
- 4. Create a new action for our users details
- 5. Create a new (ProfileScreen.js) file for our profile screen
- 6. Add our ProfileScreen to (App.js)

UPDATE USER PROFILE
- 1. Create new constants for USER_UPDATE
- 2. Create a new reducer for user update profile
- 3. Add the new reducer to (store.js)
- 4. Create a new action for updating user profiles
- 5. We should now be able to dispatch this in our (ProfileScreen.js)

SHIPPING SCREEN AND SAVE ADDRESS
- 1. Create our (ShippingScreen.js)
- 2. Add it to our (app.js)
- 3. Create an action in (cartActions.js) to save the users shipping info and continue to the next screen
- 4. Create the constants we need for the actions and reducers
- 5. Create the reducer for it in (cartReducer.js)
- 6. Since we are saving our shipping address through localStorage we want to initially load it from local storage in (store.js)
- 7. We want to add our shippingAddress as inital state in our cartReducer

CREATE THE CHECKOUT STEPS COMPONENT
- 1. Create the (CheckoutSteps.js) component
- 2. Insert the component into our (ShippingScreen.js)

PAYMENT SCREEN AND SAVE PAYMENT METHOD
- 1. Create (PaymentScreen.js)
- 2. Import (PaymentScreen.js) into our (App.js)
- 3. Create the savePaymentMethodAction
- 4. Create our constants
- 5. Create our reducer in (cartReducer.js)
- 6. Bring it into (store.js) and set our intial state or savePaymentMethod

PLACE ORDER SCREEN
- 1. Create (PlaceOrderScreen.js)
- 2. Import (PlaceOrderScreen.js) into our (App.js)
- 3. We will now need to go into our backend to create the routes for Placing an Order and adding it to the Database

ORDER CONTROLLER AND ROUTE (BACKEND FUNCTIONALITY)
- 1. Create our new (orderController.js)
- 2. Create our (orderRoutes.js) for our route
- 3. Since we created a new route we need to add it to our (server.js)
